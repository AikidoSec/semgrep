
from parsy import *
from string import whitespace as whitespace_chars

from semgrep.error import SemgrepError
from semgrep.verbose_logging import getLogger

from semdep.parsers.util import not_any
from semdep.parsers.util import extract_npm_lockfile_hash


from semgrep.semgrep_interfaces.semgrep_output_v1 import FoundDependency
from semgrep.semgrep_interfaces.semgrep_output_v1 import Ecosystem
from semgrep.semgrep_interfaces.semgrep_output_v1 import Npm
from semgrep.semgrep_interfaces.semgrep_output_v1 import Pypi
from semgrep.semgrep_interfaces.semgrep_output_v1 import Gomod
from semgrep.semgrep_interfaces.semgrep_output_v1 import Gem
from semgrep.semgrep_interfaces.semgrep_output_v1 import Cargo
from semgrep.semgrep_interfaces.semgrep_output_v1 import Maven
from semgrep.semgrep_interfaces.semgrep_output_v1 import Transitivity
from semgrep.semgrep_interfaces.semgrep_output_v1 import Direct
from semgrep.semgrep_interfaces.semgrep_output_v1 import Transitive
from semgrep.semgrep_interfaces.semgrep_output_v1 import Unknown


logger = getLogger(__name__)



@generate
def p_key_noquote():
    return (yield not_any(["\"",":",",",*whitespace_chars]))

@generate
def p_key_quote():
    yield string("\"")
    key = yield not_any(["\""])
    yield string("\"")
    return key

@generate
def p_key():
    return (yield p_key_quote | p_key_noquote)

@generate
def p_multikey():
    keys = yield p_key.sep_by(string(", "))
    return tuple(keys)

@generate
def p_value():
    return (yield not_any(["\n"]))

@generate
def p_key_value():
    yield string(" ").many()
    key = yield p_key
    yield string(" ")
    value = yield p_value
    return (key.strip("\""),value.strip("\""))    

@generate
def p_blob():
    pos = yield line_info
    yield string(" ").many()
    keys = yield p_multikey
    yield string(":\n")
    blobs = yield (p_key_value | p_blob).sep_by(string("\n"))
    return ((keys,pos),blobs)

def blobs_to_dict(blobs):
    d = {}
    for (k,v) in blobs:
        if isinstance(v,list):
            v = blobs_to_dict(v)
        d[k] = v
    return d
    
@generate
def p_source():
    at_prefix = yield string("@").optional()
    package = yield not_any(["@"])
    package = ("@" if at_prefix else "") + package
    yield string("@")
    version = yield any_char.until(eof)
    return (package,version)

YARN1_PREFIX = \
"""\
# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1


"""

@generate
def p_yarn1():
    yield string(YARN1_PREFIX)
    blobs = yield p_blob.sep_by(string("\n\n")).map(blobs_to_dict)
    yield string("\n").optional()
    deps = []
    for (sources,pos),fields in blobs.items():
        sources = [p_source.parse(s) for s in sources]
        if len(sources) < 1:
            logger.info("Found empty dependency in yarn.lock")
            continue
        package = sources[0][0]
        version = fields.get("version")
        if version is None:
            logger.info("Found dependency with no version in yarn.lock")
            continue
        integrity = fields.get("integrity")
        resolved_url = fields.get("resolved")
        deps.append(FoundDependency(
            ecosystem=Ecosystem(Npm()),
            package=package,
            version=version,
            allowed_hashes=extract_npm_lockfile_hash(integrity) if integrity else {},
            resolved_url=resolved_url,
            line_number=pos[0],
            transitivity=Transitivity(Unknown())
        ))
    return deps


YARN2_PREFIX = \
"""\
"""