from typing import TypeVar
from typing import Generic
from typing import Callable
from typing import Iterable
from typing import Tuple
from typing import List
from typing import Optional
from typing import Protocol
from typing import overload
from enum import Enum

from re import Pattern

T = TypeVar("T", covariant=True)
A = TypeVar("A")
B = TypeVar("B")

I = TypeVar("I", contravariant=True)
O = TypeVar("O", covariant=True)

class Combiner(Protocol, Generic[I, O]):
    def __call__(self, *args: I) -> O: ...

class SupportsAdd(Protocol[A]):
    def __add__(self: A, x: A) -> A: ...

Addable = TypeVar("Addable", bound=SupportsAdd)

Pos = Tuple[int, int]

class Result(Generic[T]): ...

class Parser(Generic[T]):
    def __init__(self: Parser[T], fn: Callable[[str, int], Result[T]]): ...
    def __call__(self: Parser[A], steram: str, index: int) -> Result[A]: ...
    def parse(self: Parser[A], stream: str) -> A: ...
    def parse_partial(self: Parser[A], stream: str) -> Tuple[A, str]: ...
    def bind(self: Parser[A], fn: Callable[[A], Parser[B]]) -> Parser[B]: ...
    def map(self: Parser[A], fn: Callable[[A], B]) -> Parser[B]: ...
    def combine(self: Parser[Iterable[A]], fn: Combiner[A, B]) -> Parser[B]: ...
    def concat(self: Parser[Iterable[str]]) -> Parser[str]: ...
    def then(self: Parser[A], other: Parser[B]) -> Parser[B]: ...
    def skip(self: Parser[A], other: Parser[B]) -> Parser[A]: ...
    def result(self: Parser[A], value: B) -> Parser[B]: ...
    def many(self: Parser[A]) -> Parser[List[A]]: ...
    def times(
        self: Parser[A], min: int, max: Optional[int | float] = None
    ) -> Parser[List[A]]: ...
    def at_most(self: Parser[A], n: int) -> Parser[List[A]]: ...
    def at_least(self: Parser[A], n: int) -> Parser[List[A]]: ...
    @overload
    def optional(self: Parser[A], default: B) -> Parser[A | B]: ...
    @overload
    def optional(self: Parser[A], default: None = None) -> Parser[A | None]: ...
    def until(
        self: Parser[A],
        other: Parser[A],
        min: int = 0,
        max: int | float = float("inf"),
        consume_other: bool = False,
    ) -> Parser[List[A]]: ...
    def sep_by(
        self: Parser[A],
        sep: Parser[B],
        *,
        min: int = 0,
        max: int | float = float("inf")
    ) -> Parser[List[A]]: ...
    def desc(self: Parser[A], description: str) -> Parser[A]: ...
    def mark(self: Parser[A]) -> Parser[Tuple[Pos, A, Pos]]: ...
    def tag(self: Parser[A], name: str) -> Parser[Tuple[str, A]]: ...
    def should_fail(self: Parser[A], description: str) -> Parser[None]: ...
    def __add__(self: Parser[Addable], other: Parser[Addable]) -> Parser[Addable]: ...
    def __mul__(self: Parser[A], other: int | range) -> Parser[List[A]]: ...
    def __or__(self: Parser[A], other: Parser[B]) -> Parser[A | B]: ...
    def __rshift__(self: Parser[A], other: Parser[B]) -> Parser[B]: ...
    def __lshift__(self: Parser[A], other: Parser[B]) -> Parser[A]: ...

def alt(*parsers: Parser[A]) -> Parser[A]: ...
def seq(*parsers: Parser[A]) -> Parser[List[A]]: ...
def success(value: A) -> Parser[A]: ...
def fail(expected: str) -> Parser[A]: ...
def string(
    expected_string: str, transform: Callable[[str], str] = lambda x: x
) -> Parser[str]: ...
@overload
def regex(
    exp: str | bytes | Pattern, flags: int = 0, group: int | str = 0
) -> Parser[str]: ...
@overload
def regex(
    exp: str | bytes | Pattern, flags: int, group: tuple[int, ...] | tuple[str, ...]
) -> Parser[tuple[str, ...]]: ...
def test_char(func: Callable[[str], bool], description: str) -> Parser[str]: ...
def match_char(item: str, description: Optional[str] = None) -> Parser[str]: ...
def string_from(
    *strings: str, transform: Callable[[str], str] = lambda x: x
) -> Parser[str]: ...
def char_from(string: str) -> Parser[str]: ...
def peek(parser: Parser[A]) -> Parser[A]: ...

any_char: Parser[str]
whitespace: Parser[str]
letter: Parser[str]
digit: Parser[str]
decimal_digit: Parser[str]
eof: Parser[None]
line_info: Parser[Pos]
index: Parser[int]

E = TypeVar("E", bound=Enum)

def from_enum(
    enum_cls: type[E], transform: Callable[[str], str] = lambda x: x
) -> Parser[E]: ...
