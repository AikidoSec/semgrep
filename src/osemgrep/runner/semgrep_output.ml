(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(*
  Source: protos/cli/semgrep_output.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot=''
    opens=[]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
*)
open Google_types
open Ocaml_protoc_plugin.Runtime [@@warning "-33"]
(**/**)
module Imported'modules = struct
  module Any = Any
  module Struct = Struct
end
(**/**)
module Cli = struct
  module rec CliOutput : sig
    val name': unit -> string
    type t = { version: string; errors: CliError.t list; results: CliMatch.t list; paths: CliPaths.t option; time: CliTiming.t option }
    val make : ?version:string -> ?errors:CliError.t list -> ?results:CliMatch.t list -> ?paths:CliPaths.t -> ?time:CliTiming.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.CliOutput"
    type t = { version: string; errors: CliError.t list; results: CliMatch.t list; paths: CliPaths.t option; time: CliTiming.t option }
    let make =
      fun ?version ?errors ?results ?paths ?time () ->
      let version = match version with Some v -> v | None -> {||} in
      let errors = match errors with Some v -> v | None -> [] in
      let results = match results with Some v -> v | None -> [] in
      { version; errors; results; paths; time }

    let to_proto =
      let apply = fun ~f:f' { version; errors; results; paths; time } -> f' [] version errors results paths time in
      let spec = Runtime'.Serialize.C.( basic (508888787, string, proto3) ^:: repeated (179828283, (message (fun t -> CliError.to_proto t)), not_packed) ^:: repeated (260545850, (message (fun t -> CliMatch.to_proto t)), not_packed) ^:: basic_opt (109417774, (message (fun t -> CliPaths.to_proto t))) ^:: basic_opt (3117011, (message (fun t -> CliTiming.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions version errors results paths time -> { version; errors; results; paths; time } in
      let spec = Runtime'.Deserialize.C.( basic (508888787, string, proto3) ^:: repeated (179828283, (message (fun t -> CliError.from_proto t)), not_packed) ^:: repeated (260545850, (message (fun t -> CliMatch.from_proto t)), not_packed) ^:: basic_opt (109417774, (message (fun t -> CliPaths.from_proto t))) ^:: basic_opt (3117011, (message (fun t -> CliTiming.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and Position : sig
    val name': unit -> string
    type t = { line: int; col: int; offset: int }
    val make : ?line:int -> ?col:int -> ?offset:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.Position"
    type t = { line: int; col: int; offset: int }
    let make =
      fun ?line ?col ?offset () ->
      let line = match line with Some v -> v | None -> 0 in
      let col = match col with Some v -> v | None -> 0 in
      let offset = match offset with Some v -> v | None -> 0 in
      { line; col; offset }

    let to_proto =
      let apply = fun ~f:f' { line; col; offset } -> f' [] line col offset in
      let spec = Runtime'.Serialize.C.( basic (3117964, int64_int, proto3) ^:: basic (107328, int64_int, proto3) ^:: basic (196558931, int64_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions line col offset -> { line; col; offset } in
      let spec = Runtime'.Deserialize.C.( basic (3117964, int64_int, proto3) ^:: basic (107328, int64_int, proto3) ^:: basic (196558931, int64_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and Location : sig
    val name': unit -> string
    type t = { path: string; start: Position.t option; end': Position.t option }
    val make : ?path:string -> ?start:Position.t -> ?end':Position.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.Location"
    type t = { path: string; start: Position.t option; end': Position.t option }
    let make =
      fun ?path ?start ?end' () ->
      let path = match path with Some v -> v | None -> {||} in
      { path; start; end' }

    let to_proto =
      let apply = fun ~f:f' { path; start; end' } -> f' [] path start end' in
      let spec = Runtime'.Serialize.C.( basic (3212859, string, proto3) ^:: basic_opt (110621538, (message (fun t -> Position.to_proto t))) ^:: basic_opt (99611, (message (fun t -> Position.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions path start end' -> { path; start; end' } in
      let spec = Runtime'.Deserialize.C.( basic (3212859, string, proto3) ^:: basic_opt (110621538, (message (fun t -> Position.from_proto t))) ^:: basic_opt (99611, (message (fun t -> Position.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and CoreMatch : sig
    val name': unit -> string
    type t = { rule_id: string; location: Location.t option; extra: CoreMatchExtra.t option }
    val make : ?rule_id:string -> ?location:Location.t -> ?extra:CoreMatchExtra.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.CoreMatch"
    type t = { rule_id: string; location: Location.t option; extra: CoreMatchExtra.t option }
    let make =
      fun ?rule_id ?location ?extra () ->
      let rule_id = match rule_id with Some v -> v | None -> {||} in
      { rule_id; location; extra }

    let to_proto =
      let apply = fun ~f:f' { rule_id; location; extra } -> f' [] rule_id location extra in
      let spec = Runtime'.Serialize.C.( basic (42354089, string, proto3) ^:: basic_opt (206711021, (message (fun t -> Location.to_proto t))) ^:: basic_opt (93093008, (message (fun t -> CoreMatchExtra.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions rule_id location extra -> { rule_id; location; extra } in
      let spec = Runtime'.Deserialize.C.( basic (42354089, string, proto3) ^:: basic_opt (206711021, (message (fun t -> Location.from_proto t))) ^:: basic_opt (93093008, (message (fun t -> CoreMatchExtra.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and CoreMatchExtra : sig
    module rec MetavarsEntry : sig
      val name': unit -> string
      type t = (string * MetavarValue.t option)
      val make : ?key:string -> ?value:MetavarValue.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end
    val name': unit -> string
    type t = { message: string; metavars: CoreMatchExtra.MetavarsEntry.t list; dataflow_trace: DataflowTrace.t option }
    val make : ?message:string -> ?metavars:CoreMatchExtra.MetavarsEntry.t list -> ?dataflow_trace:DataflowTrace.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    module rec MetavarsEntry : sig
      val name': unit -> string
      type t = (string * MetavarValue.t option)
      val make : ?key:string -> ?value:MetavarValue.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      let name' () = "semgrep_output.cli.CoreMatchExtra.MetavarsEntry"
      type t = (string * MetavarValue.t option)
      let make =
        fun ?key ?value () ->
        let key = match key with Some v -> v | None -> {||} in
        (key, value)

      let to_proto =
        let apply = fun ~f:f' (key, value) -> f' [] key value in
        let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> MetavarValue.to_proto t))) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t

      let from_proto =
        let constructor = fun _extensions key value -> (key, value) in
        let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> MetavarValue.from_proto t))) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error

    end
    let name' () = "semgrep_output.cli.CoreMatchExtra"
    type t = { message: string; metavars: CoreMatchExtra.MetavarsEntry.t list; dataflow_trace: DataflowTrace.t option }
    let make =
      fun ?message ?metavars ?dataflow_trace () ->
      let message = match message with Some v -> v | None -> {||} in
      let metavars = match metavars with Some v -> v | None -> [] in
      { message; metavars; dataflow_trace }

    let to_proto =
      let apply = fun ~f:f' { message; metavars; dataflow_trace } -> f' [] message metavars dataflow_trace in
      let spec = Runtime'.Serialize.C.( basic (337998899, string, proto3) ^:: repeated (81814710, (message (fun t -> CoreMatchExtra.MetavarsEntry.to_proto t)), not_packed) ^:: basic_opt (359307815, (message (fun t -> DataflowTrace.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions message metavars dataflow_trace -> { message; metavars; dataflow_trace } in
      let spec = Runtime'.Deserialize.C.( basic (337998899, string, proto3) ^:: repeated (81814710, (message (fun t -> CoreMatchExtra.MetavarsEntry.from_proto t)), not_packed) ^:: basic_opt (359307815, (message (fun t -> DataflowTrace.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and DataflowTrace : sig
    val name': unit -> string
    type t = { taint_source: Location.t list; intermediate_vars: Location.t list }
    val make : ?taint_source:Location.t list -> ?intermediate_vars:Location.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.DataflowTrace"
    type t = { taint_source: Location.t list; intermediate_vars: Location.t list }
    let make =
      fun ?taint_source ?intermediate_vars () ->
      let taint_source = match taint_source with Some v -> v | None -> [] in
      let intermediate_vars = match intermediate_vars with Some v -> v | None -> [] in
      { taint_source; intermediate_vars }

    let to_proto =
      let apply = fun ~f:f' { taint_source; intermediate_vars } -> f' [] taint_source intermediate_vars in
      let spec = Runtime'.Serialize.C.( repeated (109601574, (message (fun t -> Location.to_proto t)), not_packed) ^:: repeated (308706979, (message (fun t -> Location.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions taint_source intermediate_vars -> { taint_source; intermediate_vars } in
      let spec = Runtime'.Deserialize.C.( repeated (109601574, (message (fun t -> Location.from_proto t)), not_packed) ^:: repeated (308706979, (message (fun t -> Location.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and MetavarValue : sig
    val name': unit -> string
    type t = { start: Position.t option; end': Position.t option; abstract_content: string; propagated_value: SvalueValue.t option; unique_id: UniqueId.t option }
    val make : ?start:Position.t -> ?end':Position.t -> ?abstract_content:string -> ?propagated_value:SvalueValue.t -> ?unique_id:UniqueId.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.MetavarValue"
    type t = { start: Position.t option; end': Position.t option; abstract_content: string; propagated_value: SvalueValue.t option; unique_id: UniqueId.t option }
    let make =
      fun ?start ?end' ?abstract_content ?propagated_value ?unique_id () ->
      let abstract_content = match abstract_content with Some v -> v | None -> {||} in
      { start; end'; abstract_content; propagated_value; unique_id }

    let to_proto =
      let apply = fun ~f:f' { start; end'; abstract_content; propagated_value; unique_id } -> f' [] start end' abstract_content propagated_value unique_id in
      let spec = Runtime'.Serialize.C.( basic_opt (110621538, (message (fun t -> Position.to_proto t))) ^:: basic_opt (99611, (message (fun t -> Position.to_proto t))) ^:: basic (75232495, string, proto3) ^:: basic_opt (269991092, (message (fun t -> SvalueValue.to_proto t))) ^:: basic_opt (445148607, (message (fun t -> UniqueId.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions start end' abstract_content propagated_value unique_id -> { start; end'; abstract_content; propagated_value; unique_id } in
      let spec = Runtime'.Deserialize.C.( basic_opt (110621538, (message (fun t -> Position.from_proto t))) ^:: basic_opt (99611, (message (fun t -> Position.from_proto t))) ^:: basic (75232495, string, proto3) ^:: basic_opt (269991092, (message (fun t -> SvalueValue.from_proto t))) ^:: basic_opt (445148607, (message (fun t -> UniqueId.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and SvalueValue : sig
    val name': unit -> string
    type t = { svalue_start: Position.t option; svalue_end: Position.t option; svalue_abstract_content: string }
    val make : ?svalue_start:Position.t -> ?svalue_end:Position.t -> ?svalue_abstract_content:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.SvalueValue"
    type t = { svalue_start: Position.t option; svalue_end: Position.t option; svalue_abstract_content: string }
    let make =
      fun ?svalue_start ?svalue_end ?svalue_abstract_content () ->
      let svalue_abstract_content = match svalue_abstract_content with Some v -> v | None -> {||} in
      { svalue_start; svalue_end; svalue_abstract_content }

    let to_proto =
      let apply = fun ~f:f' { svalue_start; svalue_end; svalue_abstract_content } -> f' [] svalue_start svalue_end svalue_abstract_content in
      let spec = Runtime'.Serialize.C.( basic_opt (430292789, (message (fun t -> Position.to_proto t))) ^:: basic_opt (313081881, (message (fun t -> Position.to_proto t))) ^:: basic (526101672, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions svalue_start svalue_end svalue_abstract_content -> { svalue_start; svalue_end; svalue_abstract_content } in
      let spec = Runtime'.Deserialize.C.( basic_opt (430292789, (message (fun t -> Position.from_proto t))) ^:: basic_opt (313081881, (message (fun t -> Position.from_proto t))) ^:: basic (526101672, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and UniqueId : sig
    val name': unit -> string
    type t = { type': Imported'modules.Any.Google.Protobuf.Any.t option; md5sum: string; sid: int }
    val make : ?type':Imported'modules.Any.Google.Protobuf.Any.t -> ?md5sum:string -> ?sid:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.UniqueId"
    type t = { type': Imported'modules.Any.Google.Protobuf.Any.t option; md5sum: string; sid: int }
    let make =
      fun ?type' ?md5sum ?sid () ->
      let md5sum = match md5sum with Some v -> v | None -> {||} in
      let sid = match sid with Some v -> v | None -> 0 in
      { type'; md5sum; sid }

    let to_proto =
      let apply = fun ~f:f' { type'; md5sum; sid } -> f' [] type' md5sum sid in
      let spec = Runtime'.Serialize.C.( basic_opt (3120390, (message (fun t -> Imported'modules.Any.Google.Protobuf.Any.to_proto t))) ^:: basic (10884057, string, proto3) ^:: basic (99470, int64_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions type' md5sum sid -> { type'; md5sum; sid } in
      let spec = Runtime'.Deserialize.C.( basic_opt (3120390, (message (fun t -> Imported'modules.Any.Google.Protobuf.Any.from_proto t))) ^:: basic (10884057, string, proto3) ^:: basic (99470, int64_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and CoreError : sig
    val name': unit -> string
    type t = { rule_id: string; error_type: Imported'modules.Any.Google.Protobuf.Any.t option; severity: Imported'modules.Any.Google.Protobuf.Any.t option; location: Location.t option; message: string; details: string }
    val make : ?rule_id:string -> ?error_type:Imported'modules.Any.Google.Protobuf.Any.t -> ?severity:Imported'modules.Any.Google.Protobuf.Any.t -> ?location:Location.t -> ?message:string -> ?details:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.CoreError"
    type t = { rule_id: string; error_type: Imported'modules.Any.Google.Protobuf.Any.t option; severity: Imported'modules.Any.Google.Protobuf.Any.t option; location: Location.t option; message: string; details: string }
    let make =
      fun ?rule_id ?error_type ?severity ?location ?message ?details () ->
      let rule_id = match rule_id with Some v -> v | None -> {||} in
      let message = match message with Some v -> v | None -> {||} in
      let details = match details with Some v -> v | None -> {||} in
      { rule_id; error_type; severity; location; message; details }

    let to_proto =
      let apply = fun ~f:f' { rule_id; error_type; severity; location; message; details } -> f' [] rule_id error_type severity location message details in
      let spec = Runtime'.Serialize.C.( basic (42354089, string, proto3) ^:: basic_opt (428933134, (message (fun t -> Imported'modules.Any.Google.Protobuf.Any.to_proto t))) ^:: basic_opt (191113633, (message (fun t -> Imported'modules.Any.Google.Protobuf.Any.to_proto t))) ^:: basic_opt (206711021, (message (fun t -> Location.to_proto t))) ^:: basic (337998899, string, proto3) ^:: basic (28147206, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions rule_id error_type severity location message details -> { rule_id; error_type; severity; location; message; details } in
      let spec = Runtime'.Deserialize.C.( basic (42354089, string, proto3) ^:: basic_opt (428933134, (message (fun t -> Imported'modules.Any.Google.Protobuf.Any.from_proto t))) ^:: basic_opt (191113633, (message (fun t -> Imported'modules.Any.Google.Protobuf.Any.from_proto t))) ^:: basic_opt (206711021, (message (fun t -> Location.from_proto t))) ^:: basic (337998899, string, proto3) ^:: basic (28147206, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and CoreStats : sig
    val name': unit -> string
    type t = { okfiles: int; errorfiles: int }
    val make : ?okfiles:int -> ?errorfiles:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.CoreStats"
    type t = { okfiles: int; errorfiles: int }
    let make =
      fun ?okfiles ?errorfiles () ->
      let okfiles = match okfiles with Some v -> v | None -> 0 in
      let errorfiles = match errorfiles with Some v -> v | None -> 0 in
      { okfiles; errorfiles }

    let to_proto =
      let apply = fun ~f:f' { okfiles; errorfiles } -> f' [] okfiles errorfiles in
      let spec = Runtime'.Serialize.C.( basic (367609694, int64_int, proto3) ^:: basic (374129212, int64_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions okfiles errorfiles -> { okfiles; errorfiles } in
      let spec = Runtime'.Deserialize.C.( basic (367609694, int64_int, proto3) ^:: basic (374129212, int64_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and SkippedTarget : sig
    val name': unit -> string
    type t = { path: string; reason: Imported'modules.Any.Google.Protobuf.Any.t option; details: string; rule_id: string }
    val make : ?path:string -> ?reason:Imported'modules.Any.Google.Protobuf.Any.t -> ?details:string -> ?rule_id:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.SkippedTarget"
    type t = { path: string; reason: Imported'modules.Any.Google.Protobuf.Any.t option; details: string; rule_id: string }
    let make =
      fun ?path ?reason ?details ?rule_id () ->
      let path = match path with Some v -> v | None -> {||} in
      let details = match details with Some v -> v | None -> {||} in
      let rule_id = match rule_id with Some v -> v | None -> {||} in
      { path; reason; details; rule_id }

    let to_proto =
      let apply = fun ~f:f' { path; reason; details; rule_id } -> f' [] path reason details rule_id in
      let spec = Runtime'.Serialize.C.( basic (3212859, string, proto3) ^:: basic_opt (34014402, (message (fun t -> Imported'modules.Any.Google.Protobuf.Any.to_proto t))) ^:: basic (28147206, string, proto3) ^:: basic (42354089, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions path reason details rule_id -> { path; reason; details; rule_id } in
      let spec = Runtime'.Deserialize.C.( basic (3212859, string, proto3) ^:: basic_opt (34014402, (message (fun t -> Imported'modules.Any.Google.Protobuf.Any.from_proto t))) ^:: basic (28147206, string, proto3) ^:: basic (42354089, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and SkippedRule : sig
    val name': unit -> string
    type t = { rule_id: string; details: string; position: Position.t option }
    val make : ?rule_id:string -> ?details:string -> ?position:Position.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.SkippedRule"
    type t = { rule_id: string; details: string; position: Position.t option }
    let make =
      fun ?rule_id ?details ?position () ->
      let rule_id = match rule_id with Some v -> v | None -> {||} in
      let details = match details with Some v -> v | None -> {||} in
      { rule_id; details; position }

    let to_proto =
      let apply = fun ~f:f' { rule_id; details; position } -> f' [] rule_id details position in
      let spec = Runtime'.Serialize.C.( basic (42354089, string, proto3) ^:: basic (28147206, string, proto3) ^:: basic_opt (206964729, (message (fun t -> Position.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions rule_id details position -> { rule_id; details; position } in
      let spec = Runtime'.Deserialize.C.( basic (42354089, string, proto3) ^:: basic (28147206, string, proto3) ^:: basic_opt (206964729, (message (fun t -> Position.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and CoreTiming : sig
    val name': unit -> string
    type t = { targets: TargetTime.t list; rules: string list; rules_parse_time: float }
    val make : ?targets:TargetTime.t list -> ?rules:string list -> ?rules_parse_time:float -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.CoreTiming"
    type t = { targets: TargetTime.t list; rules: string list; rules_parse_time: float }
    let make =
      fun ?targets ?rules ?rules_parse_time () ->
      let targets = match targets with Some v -> v | None -> [] in
      let rules = match rules with Some v -> v | None -> [] in
      let rules_parse_time = match rules_parse_time with Some v -> v | None -> 0. in
      { targets; rules; rules_parse_time }

    let to_proto =
      let apply = fun ~f:f' { targets; rules; rules_parse_time } -> f' [] targets rules rules_parse_time in
      let spec = Runtime'.Serialize.C.( repeated (253663046, (message (fun t -> TargetTime.to_proto t)), not_packed) ^:: repeated (109321335, string, packed) ^:: basic (367689164, float, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions targets rules rules_parse_time -> { targets; rules; rules_parse_time } in
      let spec = Runtime'.Deserialize.C.( repeated (253663046, (message (fun t -> TargetTime.from_proto t)), not_packed) ^:: repeated (109321335, string, packed) ^:: basic (367689164, float, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and TargetTime : sig
    val name': unit -> string
    type t = { path: string; rule_times: RuleTimes.t list; run_time: float }
    val make : ?path:string -> ?rule_times:RuleTimes.t list -> ?run_time:float -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.TargetTime"
    type t = { path: string; rule_times: RuleTimes.t list; run_time: float }
    let make =
      fun ?path ?rule_times ?run_time () ->
      let path = match path with Some v -> v | None -> {||} in
      let rule_times = match rule_times with Some v -> v | None -> [] in
      let run_time = match run_time with Some v -> v | None -> 0. in
      { path; rule_times; run_time }

    let to_proto =
      let apply = fun ~f:f' { path; rule_times; run_time } -> f' [] path rule_times run_time in
      let spec = Runtime'.Serialize.C.( basic (3212859, string, proto3) ^:: repeated (352413596, (message (fun t -> RuleTimes.to_proto t)), not_packed) ^:: basic (463101456, float, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions path rule_times run_time -> { path; rule_times; run_time } in
      let spec = Runtime'.Deserialize.C.( basic (3212859, string, proto3) ^:: repeated (352413596, (message (fun t -> RuleTimes.from_proto t)), not_packed) ^:: basic (463101456, float, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and RuleTimes : sig
    val name': unit -> string
    type t = { rule_id: string; parse_time: float; match_time: float }
    val make : ?rule_id:string -> ?parse_time:float -> ?match_time:float -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.RuleTimes"
    type t = { rule_id: string; parse_time: float; match_time: float }
    let make =
      fun ?rule_id ?parse_time ?match_time () ->
      let rule_id = match rule_id with Some v -> v | None -> {||} in
      let parse_time = match parse_time with Some v -> v | None -> 0. in
      let match_time = match match_time with Some v -> v | None -> 0. in
      { rule_id; parse_time; match_time }

    let to_proto =
      let apply = fun ~f:f' { rule_id; parse_time; match_time } -> f' [] rule_id parse_time match_time in
      let spec = Runtime'.Serialize.C.( basic (42354089, string, proto3) ^:: basic (503016756, float, proto3) ^:: basic (505312582, float, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions rule_id parse_time match_time -> { rule_id; parse_time; match_time } in
      let spec = Runtime'.Deserialize.C.( basic (42354089, string, proto3) ^:: basic (503016756, float, proto3) ^:: basic (505312582, float, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and CveResult : sig
    val name': unit -> string
    type t = { url: string; filename: string; funcnames: string list }
    val make : ?url:string -> ?filename:string -> ?funcnames:string list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.CveResult"
    type t = { url: string; filename: string; funcnames: string list }
    let make =
      fun ?url ?filename ?funcnames () ->
      let url = match url with Some v -> v | None -> {||} in
      let filename = match filename with Some v -> v | None -> {||} in
      let funcnames = match funcnames with Some v -> v | None -> [] in
      { url; filename; funcnames }

    let to_proto =
      let apply = fun ~f:f' { url; filename; funcnames } -> f' [] url filename funcnames in
      let spec = Runtime'.Serialize.C.( basic (107439, string, proto3) ^:: basic (228703562, string, proto3) ^:: repeated (140608666, string, packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions url filename funcnames -> { url; filename; funcnames } in
      let spec = Runtime'.Deserialize.C.( basic (107439, string, proto3) ^:: basic (228703562, string, proto3) ^:: repeated (140608666, string, packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and CoreMatchResults : sig
    val name': unit -> string
    type t = { matches: CoreMatch.t list; errors: CoreError.t list; skipped: SkippedTarget.t list; skipped_rules: SkippedRule.t list; stats: CoreStats.t option; time: CoreTiming.t option }
    val make : ?matches:CoreMatch.t list -> ?errors:CoreError.t list -> ?skipped:SkippedTarget.t list -> ?skipped_rules:SkippedRule.t list -> ?stats:CoreStats.t -> ?time:CoreTiming.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.CoreMatchResults"
    type t = { matches: CoreMatch.t list; errors: CoreError.t list; skipped: SkippedTarget.t list; skipped_rules: SkippedRule.t list; stats: CoreStats.t option; time: CoreTiming.t option }
    let make =
      fun ?matches ?errors ?skipped ?skipped_rules ?stats ?time () ->
      let matches = match matches with Some v -> v | None -> [] in
      let errors = match errors with Some v -> v | None -> [] in
      let skipped = match skipped with Some v -> v | None -> [] in
      let skipped_rules = match skipped_rules with Some v -> v | None -> [] in
      { matches; errors; skipped; skipped_rules; stats; time }

    let to_proto =
      let apply = fun ~f:f' { matches; errors; skipped; skipped_rules; stats; time } -> f' [] matches errors skipped skipped_rules stats time in
      let spec = Runtime'.Serialize.C.( repeated (363750006, (message (fun t -> CoreMatch.to_proto t)), not_packed) ^:: repeated (179828283, (message (fun t -> CoreError.to_proto t)), not_packed) ^:: repeated (480732762, (message (fun t -> SkippedTarget.to_proto t)), not_packed) ^:: repeated (55568936, (message (fun t -> SkippedRule.to_proto t)), not_packed) ^:: basic_opt (109757599, (message (fun t -> CoreStats.to_proto t))) ^:: basic_opt (3117011, (message (fun t -> CoreTiming.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions matches errors skipped skipped_rules stats time -> { matches; errors; skipped; skipped_rules; stats; time } in
      let spec = Runtime'.Deserialize.C.( repeated (363750006, (message (fun t -> CoreMatch.from_proto t)), not_packed) ^:: repeated (179828283, (message (fun t -> CoreError.from_proto t)), not_packed) ^:: repeated (480732762, (message (fun t -> SkippedTarget.from_proto t)), not_packed) ^:: repeated (55568936, (message (fun t -> SkippedRule.from_proto t)), not_packed) ^:: basic_opt (109757599, (message (fun t -> CoreStats.from_proto t))) ^:: basic_opt (3117011, (message (fun t -> CoreTiming.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and CliError : sig
    val name': unit -> string
    type t = { code: int; level: string; type': string; rule_id: string; message: string; path: string; long_msg: string; short_msg: string; spans: ErrorSpan.t list; help: string }
    val make : ?code:int -> ?level:string -> ?type':string -> ?rule_id:string -> ?message:string -> ?path:string -> ?long_msg:string -> ?short_msg:string -> ?spans:ErrorSpan.t list -> ?help:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.CliError"
    type t = { code: int; level: string; type': string; rule_id: string; message: string; path: string; long_msg: string; short_msg: string; spans: ErrorSpan.t list; help: string }
    let make =
      fun ?code ?level ?type' ?rule_id ?message ?path ?long_msg ?short_msg ?spans ?help () ->
      let code = match code with Some v -> v | None -> 0 in
      let level = match level with Some v -> v | None -> {||} in
      let type' = match type' with Some v -> v | None -> {||} in
      let rule_id = match rule_id with Some v -> v | None -> {||} in
      let message = match message with Some v -> v | None -> {||} in
      let path = match path with Some v -> v | None -> {||} in
      let long_msg = match long_msg with Some v -> v | None -> {||} in
      let short_msg = match short_msg with Some v -> v | None -> {||} in
      let spans = match spans with Some v -> v | None -> [] in
      let help = match help with Some v -> v | None -> {||} in
      { code; level; type'; rule_id; message; path; long_msg; short_msg; spans; help }

    let to_proto =
      let apply = fun ~f:f' { code; level; type'; rule_id; message; path; long_msg; short_msg; spans; help } -> f' [] code level type' rule_id message path long_msg short_msg spans help in
      let spec = Runtime'.Serialize.C.( basic (3108531, int64_int, proto3) ^:: basic (102865796, string, proto3) ^:: basic (3120390, string, proto3) ^:: basic (42354089, string, proto3) ^:: basic (337998899, string, proto3) ^:: basic (3212859, string, proto3) ^:: basic (242299620, string, proto3) ^:: basic (7220394, string, proto3) ^:: repeated (109578729, (message (fun t -> ErrorSpan.to_proto t)), not_packed) ^:: basic (3443615, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions code level type' rule_id message path long_msg short_msg spans help -> { code; level; type'; rule_id; message; path; long_msg; short_msg; spans; help } in
      let spec = Runtime'.Deserialize.C.( basic (3108531, int64_int, proto3) ^:: basic (102865796, string, proto3) ^:: basic (3120390, string, proto3) ^:: basic (42354089, string, proto3) ^:: basic (337998899, string, proto3) ^:: basic (3212859, string, proto3) ^:: basic (242299620, string, proto3) ^:: basic (7220394, string, proto3) ^:: repeated (109578729, (message (fun t -> ErrorSpan.from_proto t)), not_packed) ^:: basic (3443615, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and ErrorSpan : sig
    val name': unit -> string
    type t = { file: string; start: PositionBis.t option; end': PositionBis.t option; source_hash: string; config_start: PositionBis.t option; config_end: PositionBis.t option; config_path: string list; context_start: PositionBis.t option; context_end: PositionBis.t option }
    val make : ?file:string -> ?start:PositionBis.t -> ?end':PositionBis.t -> ?source_hash:string -> ?config_start:PositionBis.t -> ?config_end:PositionBis.t -> ?config_path:string list -> ?context_start:PositionBis.t -> ?context_end:PositionBis.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.ErrorSpan"
    type t = { file: string; start: PositionBis.t option; end': PositionBis.t option; source_hash: string; config_start: PositionBis.t option; config_end: PositionBis.t option; config_path: string list; context_start: PositionBis.t option; context_end: PositionBis.t option }
    let make =
      fun ?file ?start ?end' ?source_hash ?config_start ?config_end ?config_path ?context_start ?context_end () ->
      let file = match file with Some v -> v | None -> {||} in
      let source_hash = match source_hash with Some v -> v | None -> {||} in
      let config_path = match config_path with Some v -> v | None -> [] in
      { file; start; end'; source_hash; config_start; config_end; config_path; context_start; context_end }

    let to_proto =
      let apply = fun ~f:f' { file; start; end'; source_hash; config_start; config_end; config_path; context_start; context_end } -> f' [] file start end' source_hash config_start config_end config_path context_start context_end in
      let spec = Runtime'.Serialize.C.( basic (3116036, string, proto3) ^:: basic_opt (110621538, (message (fun t -> PositionBis.to_proto t))) ^:: basic_opt (99611, (message (fun t -> PositionBis.to_proto t))) ^:: basic (412117553, string, proto3) ^:: basic_opt (476302353, (message (fun t -> PositionBis.to_proto t))) ^:: basic_opt (359091445, (message (fun t -> PositionBis.to_proto t))) ^:: repeated (261927867, string, packed) ^:: basic_opt (424938157, (message (fun t -> PositionBis.to_proto t))) ^:: basic_opt (12625475, (message (fun t -> PositionBis.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions file start end' source_hash config_start config_end config_path context_start context_end -> { file; start; end'; source_hash; config_start; config_end; config_path; context_start; context_end } in
      let spec = Runtime'.Deserialize.C.( basic (3116036, string, proto3) ^:: basic_opt (110621538, (message (fun t -> PositionBis.from_proto t))) ^:: basic_opt (99611, (message (fun t -> PositionBis.from_proto t))) ^:: basic (412117553, string, proto3) ^:: basic_opt (476302353, (message (fun t -> PositionBis.from_proto t))) ^:: basic_opt (359091445, (message (fun t -> PositionBis.from_proto t))) ^:: repeated (261927867, string, packed) ^:: basic_opt (424938157, (message (fun t -> PositionBis.from_proto t))) ^:: basic_opt (12625475, (message (fun t -> PositionBis.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and PositionBis : sig
    val name': unit -> string
    type t = { line: int; col: int }
    val make : ?line:int -> ?col:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.PositionBis"
    type t = { line: int; col: int }
    let make =
      fun ?line ?col () ->
      let line = match line with Some v -> v | None -> 0 in
      let col = match col with Some v -> v | None -> 0 in
      { line; col }

    let to_proto =
      let apply = fun ~f:f' { line; col } -> f' [] line col in
      let spec = Runtime'.Serialize.C.( basic (3117964, int64_int, proto3) ^:: basic (107328, int64_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions line col -> { line; col } in
      let spec = Runtime'.Deserialize.C.( basic (3117964, int64_int, proto3) ^:: basic (107328, int64_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and CliMatch : sig
    val name': unit -> string
    type t = { check_id: string; path: string; start: Position.t option; end': Position.t option; extra: CliMatchExtra.t option }
    val make : ?check_id:string -> ?path:string -> ?start:Position.t -> ?end':Position.t -> ?extra:CliMatchExtra.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.CliMatch"
    type t = { check_id: string; path: string; start: Position.t option; end': Position.t option; extra: CliMatchExtra.t option }
    let make =
      fun ?check_id ?path ?start ?end' ?extra () ->
      let check_id = match check_id with Some v -> v | None -> {||} in
      let path = match path with Some v -> v | None -> {||} in
      { check_id; path; start; end'; extra }

    let to_proto =
      let apply = fun ~f:f' { check_id; path; start; end'; extra } -> f' [] check_id path start end' extra in
      let spec = Runtime'.Serialize.C.( basic (244492357, string, proto3) ^:: basic (3212859, string, proto3) ^:: basic_opt (110621538, (message (fun t -> Position.to_proto t))) ^:: basic_opt (99611, (message (fun t -> Position.to_proto t))) ^:: basic_opt (93093008, (message (fun t -> CliMatchExtra.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions check_id path start end' extra -> { check_id; path; start; end'; extra } in
      let spec = Runtime'.Deserialize.C.( basic (244492357, string, proto3) ^:: basic (3212859, string, proto3) ^:: basic_opt (110621538, (message (fun t -> Position.from_proto t))) ^:: basic_opt (99611, (message (fun t -> Position.from_proto t))) ^:: basic_opt (93093008, (message (fun t -> CliMatchExtra.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and CliMatchExtra : sig
    module rec MetavarsEntry : sig
      val name': unit -> string
      type t = (string * MetavarValue.t option)
      val make : ?key:string -> ?value:MetavarValue.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end
    val name': unit -> string
    type t = { metavars: CliMatchExtra.MetavarsEntry.t list; fingerprint: string; lines: string; message: string; metadata: Imported'modules.Any.Google.Protobuf.Any.t option; severity: string; fix: string; fix_regex: FixRegex.t option; is_ignored: bool; dependency_match_only: bool; dependency_matches: Imported'modules.Any.Google.Protobuf.Any.t option; fixed_lines: string list; dataflow_trace: DataflowTrace.t option }
    val make : ?metavars:CliMatchExtra.MetavarsEntry.t list -> ?fingerprint:string -> ?lines:string -> ?message:string -> ?metadata:Imported'modules.Any.Google.Protobuf.Any.t -> ?severity:string -> ?fix:string -> ?fix_regex:FixRegex.t -> ?is_ignored:bool -> ?dependency_match_only:bool -> ?dependency_matches:Imported'modules.Any.Google.Protobuf.Any.t -> ?fixed_lines:string list -> ?dataflow_trace:DataflowTrace.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    module rec MetavarsEntry : sig
      val name': unit -> string
      type t = (string * MetavarValue.t option)
      val make : ?key:string -> ?value:MetavarValue.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      let name' () = "semgrep_output.cli.CliMatchExtra.MetavarsEntry"
      type t = (string * MetavarValue.t option)
      let make =
        fun ?key ?value () ->
        let key = match key with Some v -> v | None -> {||} in
        (key, value)

      let to_proto =
        let apply = fun ~f:f' (key, value) -> f' [] key value in
        let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> MetavarValue.to_proto t))) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t

      let from_proto =
        let constructor = fun _extensions key value -> (key, value) in
        let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic_opt (2, (message (fun t -> MetavarValue.from_proto t))) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error

    end
    let name' () = "semgrep_output.cli.CliMatchExtra"
    type t = { metavars: CliMatchExtra.MetavarsEntry.t list; fingerprint: string; lines: string; message: string; metadata: Imported'modules.Any.Google.Protobuf.Any.t option; severity: string; fix: string; fix_regex: FixRegex.t option; is_ignored: bool; dependency_match_only: bool; dependency_matches: Imported'modules.Any.Google.Protobuf.Any.t option; fixed_lines: string list; dataflow_trace: DataflowTrace.t option }
    let make =
      fun ?metavars ?fingerprint ?lines ?message ?metadata ?severity ?fix ?fix_regex ?is_ignored ?dependency_match_only ?dependency_matches ?fixed_lines ?dataflow_trace () ->
      let metavars = match metavars with Some v -> v | None -> [] in
      let fingerprint = match fingerprint with Some v -> v | None -> {||} in
      let lines = match lines with Some v -> v | None -> {||} in
      let message = match message with Some v -> v | None -> {||} in
      let severity = match severity with Some v -> v | None -> {||} in
      let fix = match fix with Some v -> v | None -> {||} in
      let is_ignored = match is_ignored with Some v -> v | None -> false in
      let dependency_match_only = match dependency_match_only with Some v -> v | None -> false in
      let fixed_lines = match fixed_lines with Some v -> v | None -> [] in
      { metavars; fingerprint; lines; message; metadata; severity; fix; fix_regex; is_ignored; dependency_match_only; dependency_matches; fixed_lines; dataflow_trace }

    let to_proto =
      let apply = fun ~f:f' { metavars; fingerprint; lines; message; metadata; severity; fix; fix_regex; is_ignored; dependency_match_only; dependency_matches; fixed_lines; dataflow_trace } -> f' [] metavars fingerprint lines message metadata severity fix fix_regex is_ignored dependency_match_only dependency_matches fixed_lines dataflow_trace in
      let spec = Runtime'.Serialize.C.( repeated (81814710, (message (fun t -> CliMatchExtra.MetavarsEntry.to_proto t)), not_packed) ^:: basic (426561151, string, proto3) ^:: basic (109322879, string, proto3) ^:: basic (337998899, string, proto3) ^:: basic_opt (534382816, (message (fun t -> Imported'modules.Any.Google.Protobuf.Any.to_proto t))) ^:: basic (191113633, string, proto3) ^:: basic (118677, string, proto3) ^:: basic_opt (391937584, (message (fun t -> FixRegex.to_proto t))) ^:: basic (531173073, bool, proto3) ^:: basic (379345809, bool, proto3) ^:: basic_opt (288721032, (message (fun t -> Imported'modules.Any.Google.Protobuf.Any.to_proto t))) ^:: repeated (405597072, string, packed) ^:: basic_opt (359307815, (message (fun t -> DataflowTrace.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions metavars fingerprint lines message metadata severity fix fix_regex is_ignored dependency_match_only dependency_matches fixed_lines dataflow_trace -> { metavars; fingerprint; lines; message; metadata; severity; fix; fix_regex; is_ignored; dependency_match_only; dependency_matches; fixed_lines; dataflow_trace } in
      let spec = Runtime'.Deserialize.C.( repeated (81814710, (message (fun t -> CliMatchExtra.MetavarsEntry.from_proto t)), not_packed) ^:: basic (426561151, string, proto3) ^:: basic (109322879, string, proto3) ^:: basic (337998899, string, proto3) ^:: basic_opt (534382816, (message (fun t -> Imported'modules.Any.Google.Protobuf.Any.from_proto t))) ^:: basic (191113633, string, proto3) ^:: basic (118677, string, proto3) ^:: basic_opt (391937584, (message (fun t -> FixRegex.from_proto t))) ^:: basic (531173073, bool, proto3) ^:: basic (379345809, bool, proto3) ^:: basic_opt (288721032, (message (fun t -> Imported'modules.Any.Google.Protobuf.Any.from_proto t))) ^:: repeated (405597072, string, packed) ^:: basic_opt (359307815, (message (fun t -> DataflowTrace.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and FixRegex : sig
    val name': unit -> string
    type t = { regex: string; replacement: string; count: int }
    val make : ?regex:string -> ?replacement:string -> ?count:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.FixRegex"
    type t = { regex: string; replacement: string; count: int }
    let make =
      fun ?regex ?replacement ?count () ->
      let regex = match regex with Some v -> v | None -> {||} in
      let replacement = match replacement with Some v -> v | None -> {||} in
      let count = match count with Some v -> v | None -> 0 in
      { regex; replacement; count }

    let to_proto =
      let apply = fun ~f:f' { regex; replacement; count } -> f' [] regex replacement count in
      let spec = Runtime'.Serialize.C.( basic (113933639, string, proto3) ^:: basic (21088776, string, proto3) ^:: basic (110521423, int64_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions regex replacement count -> { regex; replacement; count } in
      let spec = Runtime'.Deserialize.C.( basic (113933639, string, proto3) ^:: basic (21088776, string, proto3) ^:: basic (110521423, int64_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and CliOutputExtra : sig
    val name': unit -> string
    type t = { paths: CliPaths.t option; time: CliTiming.t option }
    val make : ?paths:CliPaths.t -> ?time:CliTiming.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.CliOutputExtra"
    type t = { paths: CliPaths.t option; time: CliTiming.t option }
    let make =
      fun ?paths ?time () ->

      { paths; time }

    let to_proto =
      let apply = fun ~f:f' { paths; time } -> f' [] paths time in
      let spec = Runtime'.Serialize.C.( basic_opt (109417774, (message (fun t -> CliPaths.to_proto t))) ^:: basic_opt (3117011, (message (fun t -> CliTiming.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions paths time -> { paths; time } in
      let spec = Runtime'.Deserialize.C.( basic_opt (109417774, (message (fun t -> CliPaths.from_proto t))) ^:: basic_opt (3117011, (message (fun t -> CliTiming.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and CliPaths : sig
    val name': unit -> string
    type t = { scanned: string list; _comment: string; skipped: CliSkippedTarget.t list }
    val make : ?scanned:string list -> ?_comment:string -> ?skipped:CliSkippedTarget.t list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.CliPaths"
    type t = { scanned: string list; _comment: string; skipped: CliSkippedTarget.t list }
    let make =
      fun ?scanned ?_comment ?skipped () ->
      let scanned = match scanned with Some v -> v | None -> [] in
      let _comment = match _comment with Some v -> v | None -> {||} in
      let skipped = match skipped with Some v -> v | None -> [] in
      { scanned; _comment; skipped }

    let to_proto =
      let apply = fun ~f:f' { scanned; _comment; skipped } -> f' [] scanned _comment skipped in
      let spec = Runtime'.Serialize.C.( repeated (478818202, string, packed) ^:: basic (528651539, string, proto3) ^:: repeated (480732762, (message (fun t -> CliSkippedTarget.to_proto t)), not_packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions scanned _comment skipped -> { scanned; _comment; skipped } in
      let spec = Runtime'.Deserialize.C.( repeated (478818202, string, packed) ^:: basic (528651539, string, proto3) ^:: repeated (480732762, (message (fun t -> CliSkippedTarget.from_proto t)), not_packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and CliSkippedTarget : sig
    val name': unit -> string
    type t = { path: string; reason: string }
    val make : ?path:string -> ?reason:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.CliSkippedTarget"
    type t = { path: string; reason: string }
    let make =
      fun ?path ?reason () ->
      let path = match path with Some v -> v | None -> {||} in
      let reason = match reason with Some v -> v | None -> {||} in
      { path; reason }

    let to_proto =
      let apply = fun ~f:f' { path; reason } -> f' [] path reason in
      let spec = Runtime'.Serialize.C.( basic (3212859, string, proto3) ^:: basic (34014402, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions path reason -> { path; reason } in
      let spec = Runtime'.Deserialize.C.( basic (3212859, string, proto3) ^:: basic (34014402, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and CliTiming : sig
    module rec ProfilingTimesEntry : sig
      val name': unit -> string
      type t = (string * float)
      val make : ?key:string -> ?value:float -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end
    val name': unit -> string
    type t = { rules: RuleIdDict.t list; rules_parse_time: float; profiling_times: CliTiming.ProfilingTimesEntry.t list; targets: CliTargetTimes.t list; total_bytes: int }
    val make : ?rules:RuleIdDict.t list -> ?rules_parse_time:float -> ?profiling_times:CliTiming.ProfilingTimesEntry.t list -> ?targets:CliTargetTimes.t list -> ?total_bytes:int -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    module rec ProfilingTimesEntry : sig
      val name': unit -> string
      type t = (string * float)
      val make : ?key:string -> ?value:float -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      let name' () = "semgrep_output.cli.CliTiming.ProfilingTimesEntry"
      type t = (string * float)
      let make =
        fun ?key ?value () ->
        let key = match key with Some v -> v | None -> {||} in
        let value = match value with Some v -> v | None -> 0. in
        (key, value)

      let to_proto =
        let apply = fun ~f:f' (key, value) -> f' [] key value in
        let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, float, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t

      let from_proto =
        let constructor = fun _extensions key value -> (key, value) in
        let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, float, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error

    end
    let name' () = "semgrep_output.cli.CliTiming"
    type t = { rules: RuleIdDict.t list; rules_parse_time: float; profiling_times: CliTiming.ProfilingTimesEntry.t list; targets: CliTargetTimes.t list; total_bytes: int }
    let make =
      fun ?rules ?rules_parse_time ?profiling_times ?targets ?total_bytes () ->
      let rules = match rules with Some v -> v | None -> [] in
      let rules_parse_time = match rules_parse_time with Some v -> v | None -> 0. in
      let profiling_times = match profiling_times with Some v -> v | None -> [] in
      let targets = match targets with Some v -> v | None -> [] in
      let total_bytes = match total_bytes with Some v -> v | None -> 0 in
      { rules; rules_parse_time; profiling_times; targets; total_bytes }

    let to_proto =
      let apply = fun ~f:f' { rules; rules_parse_time; profiling_times; targets; total_bytes } -> f' [] rules rules_parse_time profiling_times targets total_bytes in
      let spec = Runtime'.Serialize.C.( repeated (109321335, (message (fun t -> RuleIdDict.to_proto t)), not_packed) ^:: basic (367689164, float, proto3) ^:: repeated (190109087, (message (fun t -> CliTiming.ProfilingTimesEntry.to_proto t)), not_packed) ^:: repeated (253663046, (message (fun t -> CliTargetTimes.to_proto t)), not_packed) ^:: basic (525010859, int64_int, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions rules rules_parse_time profiling_times targets total_bytes -> { rules; rules_parse_time; profiling_times; targets; total_bytes } in
      let spec = Runtime'.Deserialize.C.( repeated (109321335, (message (fun t -> RuleIdDict.from_proto t)), not_packed) ^:: basic (367689164, float, proto3) ^:: repeated (190109087, (message (fun t -> CliTiming.ProfilingTimesEntry.from_proto t)), not_packed) ^:: repeated (253663046, (message (fun t -> CliTargetTimes.from_proto t)), not_packed) ^:: basic (525010859, int64_int, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and RuleIdDict : sig
    val name': unit -> string
    type t = string
    val make : ?id:string -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.RuleIdDict"
    type t = string
    let make =
      fun ?id () ->
      let id = match id with Some v -> v | None -> {||} in
      id

    let to_proto =
      let apply = fun ~f:f' id -> f' [] id in
      let spec = Runtime'.Serialize.C.( basic (3205, string, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions id -> id in
      let spec = Runtime'.Deserialize.C.( basic (3205, string, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and CliTargetTimes : sig
    val name': unit -> string
    type t = { path: string; num_bytes: int; match_times: float list; parse_times: float list; run_time: float }
    val make : ?path:string -> ?num_bytes:int -> ?match_times:float list -> ?parse_times:float list -> ?run_time:float -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.CliTargetTimes"
    type t = { path: string; num_bytes: int; match_times: float list; parse_times: float list; run_time: float }
    let make =
      fun ?path ?num_bytes ?match_times ?parse_times ?run_time () ->
      let path = match path with Some v -> v | None -> {||} in
      let num_bytes = match num_bytes with Some v -> v | None -> 0 in
      let match_times = match match_times with Some v -> v | None -> [] in
      let parse_times = match parse_times with Some v -> v | None -> [] in
      let run_time = match run_time with Some v -> v | None -> 0. in
      { path; num_bytes; match_times; parse_times; run_time }

    let to_proto =
      let apply = fun ~f:f' { path; num_bytes; match_times; parse_times; run_time } -> f' [] path num_bytes match_times parse_times run_time in
      let spec = Runtime'.Serialize.C.( basic (3212859, string, proto3) ^:: basic (49709845, int64_int, proto3) ^:: repeated (189904321, float, packed) ^:: repeated (187608495, float, packed) ^:: basic (463101456, float, proto3) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions path num_bytes match_times parse_times run_time -> { path; num_bytes; match_times; parse_times; run_time } in
      let spec = Runtime'.Deserialize.C.( basic (3212859, string, proto3) ^:: basic (49709845, int64_int, proto3) ^:: repeated (189904321, float, packed) ^:: repeated (187608495, float, packed) ^:: basic (463101456, float, proto3) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and ApiScansFindings : sig
    val name': unit -> string
    type t = { findings: Finding.t list; token: string; gitlab_token: string; searched_paths: string list; rule_ids: string list; cai_ids: string list }
    val make : ?findings:Finding.t list -> ?token:string -> ?gitlab_token:string -> ?searched_paths:string list -> ?rule_ids:string list -> ?cai_ids:string list -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.ApiScansFindings"
    type t = { findings: Finding.t list; token: string; gitlab_token: string; searched_paths: string list; rule_ids: string list; cai_ids: string list }
    let make =
      fun ?findings ?token ?gitlab_token ?searched_paths ?rule_ids ?cai_ids () ->
      let findings = match findings with Some v -> v | None -> [] in
      let token = match token with Some v -> v | None -> {||} in
      let gitlab_token = match gitlab_token with Some v -> v | None -> {||} in
      let searched_paths = match searched_paths with Some v -> v | None -> [] in
      let rule_ids = match rule_ids with Some v -> v | None -> [] in
      let cai_ids = match cai_ids with Some v -> v | None -> [] in
      { findings; token; gitlab_token; searched_paths; rule_ids; cai_ids }

    let to_proto =
      let apply = fun ~f:f' { findings; token; gitlab_token; searched_paths; rule_ids; cai_ids } -> f' [] findings token gitlab_token searched_paths rule_ids cai_ids in
      let spec = Runtime'.Serialize.C.( repeated (343207531, (message (fun t -> Finding.to_proto t)), not_packed) ^:: basic (104702585, string, proto3) ^:: basic (284934747, string, proto3) ^:: repeated (302953681, string, packed) ^:: repeated (212698331, string, packed) ^:: repeated (335914631, string, packed) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions findings token gitlab_token searched_paths rule_ids cai_ids -> { findings; token; gitlab_token; searched_paths; rule_ids; cai_ids } in
      let spec = Runtime'.Deserialize.C.( repeated (343207531, (message (fun t -> Finding.from_proto t)), not_packed) ^:: basic (104702585, string, proto3) ^:: basic (284934747, string, proto3) ^:: repeated (302953681, string, packed) ^:: repeated (212698331, string, packed) ^:: repeated (335914631, string, packed) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and Finding : sig
    val name': unit -> string
    type t = { check_id: string; path: string; line: int; column: int; end_line: int; end_column: int; message: string; severity: int; index: int; commit_date: string; syntactic_id: string; match_based_id: string; metadata: Imported'modules.Struct.Google.Protobuf.Struct.t option; is_blocking: bool; fixed_lines: string list; sca_info: ScaInfo.t option; dataflow_trace: DataflowTrace.t option }
    val make : ?check_id:string -> ?path:string -> ?line:int -> ?column:int -> ?end_line:int -> ?end_column:int -> ?message:string -> ?severity:int -> ?index:int -> ?commit_date:string -> ?syntactic_id:string -> ?match_based_id:string -> ?metadata:Imported'modules.Struct.Google.Protobuf.Struct.t -> ?is_blocking:bool -> ?fixed_lines:string list -> ?sca_info:ScaInfo.t -> ?dataflow_trace:DataflowTrace.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.Finding"
    type t = { check_id: string; path: string; line: int; column: int; end_line: int; end_column: int; message: string; severity: int; index: int; commit_date: string; syntactic_id: string; match_based_id: string; metadata: Imported'modules.Struct.Google.Protobuf.Struct.t option; is_blocking: bool; fixed_lines: string list; sca_info: ScaInfo.t option; dataflow_trace: DataflowTrace.t option }
    let make =
      fun ?check_id ?path ?line ?column ?end_line ?end_column ?message ?severity ?index ?commit_date ?syntactic_id ?match_based_id ?metadata ?is_blocking ?fixed_lines ?sca_info ?dataflow_trace () ->
      let check_id = match check_id with Some v -> v | None -> {||} in
      let path = match path with Some v -> v | None -> {||} in
      let line = match line with Some v -> v | None -> 0 in
      let column = match column with Some v -> v | None -> 0 in
      let end_line = match end_line with Some v -> v | None -> 0 in
      let end_column = match end_column with Some v -> v | None -> 0 in
      let message = match message with Some v -> v | None -> {||} in
      let severity = match severity with Some v -> v | None -> 0 in
      let index = match index with Some v -> v | None -> 0 in
      let commit_date = match commit_date with Some v -> v | None -> {||} in
      let syntactic_id = match syntactic_id with Some v -> v | None -> {||} in
      let match_based_id = match match_based_id with Some v -> v | None -> {||} in
      let is_blocking = match is_blocking with Some v -> v | None -> false in
      let fixed_lines = match fixed_lines with Some v -> v | None -> [] in
      { check_id; path; line; column; end_line; end_column; message; severity; index; commit_date; syntactic_id; match_based_id; metadata; is_blocking; fixed_lines; sca_info; dataflow_trace }

    let to_proto =
      let apply = fun ~f:f' { check_id; path; line; column; end_line; end_column; message; severity; index; commit_date; syntactic_id; match_based_id; metadata; is_blocking; fixed_lines; sca_info; dataflow_trace } -> f' [] check_id path line column end_line end_column message severity index commit_date syntactic_id match_based_id metadata is_blocking fixed_lines sca_info dataflow_trace in
      let spec = Runtime'.Serialize.C.( basic (244492357, string, proto3) ^:: basic (3212859, string, proto3) ^:: basic (3117964, int64_int, proto3) ^:: basic (32237808, int64_int, proto3) ^:: basic (269465307, int64_int, proto3) ^:: basic (119242219, int64_int, proto3) ^:: basic (337998899, string, proto3) ^:: basic (191113633, int64_int, proto3) ^:: basic (113931026, int64_int, proto3) ^:: basic (139249355, string, proto3) ^:: basic (386155329, string, proto3) ^:: basic (394189736, string, proto3) ^:: basic_opt (534382816, (message (fun t -> Imported'modules.Struct.Google.Protobuf.Struct.to_proto t))) ^:: basic (487146492, bool, proto3) ^:: repeated (405597072, string, packed) ^:: basic_opt (493451, (message (fun t -> ScaInfo.to_proto t))) ^:: basic_opt (359307815, (message (fun t -> DataflowTrace.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions check_id path line column end_line end_column message severity index commit_date syntactic_id match_based_id metadata is_blocking fixed_lines sca_info dataflow_trace -> { check_id; path; line; column; end_line; end_column; message; severity; index; commit_date; syntactic_id; match_based_id; metadata; is_blocking; fixed_lines; sca_info; dataflow_trace } in
      let spec = Runtime'.Deserialize.C.( basic (244492357, string, proto3) ^:: basic (3212859, string, proto3) ^:: basic (3117964, int64_int, proto3) ^:: basic (32237808, int64_int, proto3) ^:: basic (269465307, int64_int, proto3) ^:: basic (119242219, int64_int, proto3) ^:: basic (337998899, string, proto3) ^:: basic (191113633, int64_int, proto3) ^:: basic (113931026, int64_int, proto3) ^:: basic (139249355, string, proto3) ^:: basic (386155329, string, proto3) ^:: basic (394189736, string, proto3) ^:: basic_opt (534382816, (message (fun t -> Imported'modules.Struct.Google.Protobuf.Struct.from_proto t))) ^:: basic (487146492, bool, proto3) ^:: repeated (405597072, string, packed) ^:: basic_opt (493451, (message (fun t -> ScaInfo.from_proto t))) ^:: basic_opt (359307815, (message (fun t -> DataflowTrace.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
  and ScaInfo : sig
    val name': unit -> string
    type t = { dependency_match_only: bool; dependency_matches: Imported'modules.Struct.Google.Protobuf.Struct.t option }
    val make : ?dependency_match_only:bool -> ?dependency_matches:Imported'modules.Struct.Google.Protobuf.Struct.t -> unit -> t
    val to_proto: t -> Runtime'.Writer.t
    val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
  end = struct
    let name' () = "semgrep_output.cli.ScaInfo"
    type t = { dependency_match_only: bool; dependency_matches: Imported'modules.Struct.Google.Protobuf.Struct.t option }
    let make =
      fun ?dependency_match_only ?dependency_matches () ->
      let dependency_match_only = match dependency_match_only with Some v -> v | None -> false in
      { dependency_match_only; dependency_matches }

    let to_proto =
      let apply = fun ~f:f' { dependency_match_only; dependency_matches } -> f' [] dependency_match_only dependency_matches in
      let spec = Runtime'.Serialize.C.( basic (379345809, bool, proto3) ^:: basic_opt (288721032, (message (fun t -> Imported'modules.Struct.Google.Protobuf.Struct.to_proto t))) ^:: nil ) in
      let serialize = Runtime'.Serialize.serialize [] (spec) in
      fun t -> apply ~f:serialize t

    let from_proto =
      let constructor = fun _extensions dependency_match_only dependency_matches -> { dependency_match_only; dependency_matches } in
      let spec = Runtime'.Deserialize.C.( basic (379345809, bool, proto3) ^:: basic_opt (288721032, (message (fun t -> Imported'modules.Struct.Google.Protobuf.Struct.from_proto t))) ^:: nil ) in
      let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
      fun writer -> deserialize writer |> Runtime'.Result.open_error

  end
end
