(************************************************)
(*       AUTOGENERATED FILE - DO NOT EDIT!      *)
(************************************************)
(* Generated by: ocaml-protoc-plugin            *)
(* https://github.com/issuu/ocaml-protoc-plugin *)
(************************************************)
(*
  Source: protos/runner/runner.proto
  Syntax: proto3
  Parameters:
    debug=false
    annot='[@@deriving show { with_path = false }]'
    opens=[]
    int64_as_int=true
    int32_as_int=true
    fixed_as_int=false
    singleton_record=false
*)

open Ocaml_protoc_plugin.Runtime [@@warning "-33"]
(**/**)
module Imported'modules = struct
  module Semgrep_output = Semgrep_output
end
(**/**)
module Protos = struct
  module Runner = struct
    module rec Target : sig
      val name': unit -> string
      type t = { name: string; content: string } [@@deriving show { with_path = false }]
      val make : ?name:string -> ?content:string -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      let name' () = "runner.protos.runner.Target"
      type t = { name: string; content: string }[@@deriving show { with_path = false }]
      let make =
        fun ?name ?content () ->
        let name = match name with Some v -> v | None -> {||} in
        let content = match content with Some v -> v | None -> {||} in
        { name; content }

      let to_proto =
        let apply = fun ~f:f' { name; content } -> f' [] name content in
        let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t

      let from_proto =
        let constructor = fun _extensions name content -> { name; content } in
        let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error

    end
    and RunOptions : sig
      val name': unit -> string
      type t = { strict: bool; autofix: bool; dryrun: bool; no_rewrite_rule_ids: bool; matching_explanations: bool; use_pro_engine: bool } [@@deriving show { with_path = false }]
      val make : ?strict:bool -> ?autofix:bool -> ?dryrun:bool -> ?no_rewrite_rule_ids:bool -> ?matching_explanations:bool -> ?use_pro_engine:bool -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      let name' () = "runner.protos.runner.RunOptions"
      type t = { strict: bool; autofix: bool; dryrun: bool; no_rewrite_rule_ids: bool; matching_explanations: bool; use_pro_engine: bool }[@@deriving show { with_path = false }]
      let make =
        fun ?strict ?autofix ?dryrun ?no_rewrite_rule_ids ?matching_explanations ?use_pro_engine () ->
        let strict = match strict with Some v -> v | None -> false in
        let autofix = match autofix with Some v -> v | None -> false in
        let dryrun = match dryrun with Some v -> v | None -> false in
        let no_rewrite_rule_ids = match no_rewrite_rule_ids with Some v -> v | None -> false in
        let matching_explanations = match matching_explanations with Some v -> v | None -> false in
        let use_pro_engine = match use_pro_engine with Some v -> v | None -> false in
        { strict; autofix; dryrun; no_rewrite_rule_ids; matching_explanations; use_pro_engine }

      let to_proto =
        let apply = fun ~f:f' { strict; autofix; dryrun; no_rewrite_rule_ids; matching_explanations; use_pro_engine } -> f' [] strict autofix dryrun no_rewrite_rule_ids matching_explanations use_pro_engine in
        let spec = Runtime'.Serialize.C.( basic (1, bool, proto3) ^:: basic (2, bool, proto3) ^:: basic (3, bool, proto3) ^:: basic (4, bool, proto3) ^:: basic (5, bool, proto3) ^:: basic (6, bool, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t

      let from_proto =
        let constructor = fun _extensions strict autofix dryrun no_rewrite_rule_ids matching_explanations use_pro_engine -> { strict; autofix; dryrun; no_rewrite_rule_ids; matching_explanations; use_pro_engine } in
        let spec = Runtime'.Deserialize.C.( basic (1, bool, proto3) ^:: basic (2, bool, proto3) ^:: basic (3, bool, proto3) ^:: basic (4, bool, proto3) ^:: basic (5, bool, proto3) ^:: basic (6, bool, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error

    end
    and SearchStreamRequest : sig
      val name': unit -> string
      type t = { target: Target.t option; options: RunOptions.t option } [@@deriving show { with_path = false }]
      val make : ?target:Target.t -> ?options:RunOptions.t -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      let name' () = "runner.protos.runner.SearchStreamRequest"
      type t = { target: Target.t option; options: RunOptions.t option }[@@deriving show { with_path = false }]
      let make =
        fun ?target ?options () ->

        { target; options }

      let to_proto =
        let apply = fun ~f:f' { target; options } -> f' [] target options in
        let spec = Runtime'.Serialize.C.( basic_opt (2, (message (fun t -> Target.to_proto t))) ^:: basic_opt (3, (message (fun t -> RunOptions.to_proto t))) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t

      let from_proto =
        let constructor = fun _extensions target options -> { target; options } in
        let spec = Runtime'.Deserialize.C.( basic_opt (2, (message (fun t -> Target.from_proto t))) ^:: basic_opt (3, (message (fun t -> RunOptions.from_proto t))) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error

    end
    and ResultPosition : sig
      val name': unit -> string
      type t = { line: int; col: int; offset: int } [@@deriving show { with_path = false }]
      val make : ?line:int -> ?col:int -> ?offset:int -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      let name' () = "runner.protos.runner.ResultPosition"
      type t = { line: int; col: int; offset: int }[@@deriving show { with_path = false }]
      let make =
        fun ?line ?col ?offset () ->
        let line = match line with Some v -> v | None -> 0 in
        let col = match col with Some v -> v | None -> 0 in
        let offset = match offset with Some v -> v | None -> 0 in
        { line; col; offset }

      let to_proto =
        let apply = fun ~f:f' { line; col; offset } -> f' [] line col offset in
        let spec = Runtime'.Serialize.C.( basic (3117964, int64_int, proto3) ^:: basic (107328, int64_int, proto3) ^:: basic (196558931, int64_int, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t

      let from_proto =
        let constructor = fun _extensions line col offset -> { line; col; offset } in
        let spec = Runtime'.Deserialize.C.( basic (3117964, int64_int, proto3) ^:: basic (107328, int64_int, proto3) ^:: basic (196558931, int64_int, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error

    end
    and RunnerResult : sig
      val name': unit -> string
      type t = { check_id: string; path: string; start: ResultPosition.t option; end': ResultPosition.t option; fixed_lines: string list } [@@deriving show { with_path = false }]
      val make : ?check_id:string -> ?path:string -> ?start:ResultPosition.t -> ?end':ResultPosition.t -> ?fixed_lines:string list -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      let name' () = "runner.protos.runner.RunnerResult"
      type t = { check_id: string; path: string; start: ResultPosition.t option; end': ResultPosition.t option; fixed_lines: string list }[@@deriving show { with_path = false }]
      let make =
        fun ?check_id ?path ?start ?end' ?fixed_lines () ->
        let check_id = match check_id with Some v -> v | None -> {||} in
        let path = match path with Some v -> v | None -> {||} in
        let fixed_lines = match fixed_lines with Some v -> v | None -> [] in
        { check_id; path; start; end'; fixed_lines }

      let to_proto =
        let apply = fun ~f:f' { check_id; path; start; end'; fixed_lines } -> f' [] check_id path start end' fixed_lines in
        let spec = Runtime'.Serialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: basic_opt (3, (message (fun t -> ResultPosition.to_proto t))) ^:: basic_opt (4, (message (fun t -> ResultPosition.to_proto t))) ^:: repeated (5, string, packed) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t

      let from_proto =
        let constructor = fun _extensions check_id path start end' fixed_lines -> { check_id; path; start; end'; fixed_lines } in
        let spec = Runtime'.Deserialize.C.( basic (1, string, proto3) ^:: basic (2, string, proto3) ^:: basic_opt (3, (message (fun t -> ResultPosition.from_proto t))) ^:: basic_opt (4, (message (fun t -> ResultPosition.from_proto t))) ^:: repeated (5, string, packed) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error

    end
    and SearchStreamResponse : sig
      val name': unit -> string
      type t = { results: RunnerResult.t list; output: string } [@@deriving show { with_path = false }]
      val make : ?results:RunnerResult.t list -> ?output:string -> unit -> t
      val to_proto: t -> Runtime'.Writer.t
      val from_proto: Runtime'.Reader.t -> (t, [> Runtime'.Result.error]) result
    end = struct
      let name' () = "runner.protos.runner.SearchStreamResponse"
      type t = { results: RunnerResult.t list; output: string }[@@deriving show { with_path = false }]
      let make =
        fun ?results ?output () ->
        let results = match results with Some v -> v | None -> [] in
        let output = match output with Some v -> v | None -> {||} in
        { results; output }

      let to_proto =
        let apply = fun ~f:f' { results; output } -> f' [] results output in
        let spec = Runtime'.Serialize.C.( repeated (1, (message (fun t -> RunnerResult.to_proto t)), not_packed) ^:: basic (2, string, proto3) ^:: nil ) in
        let serialize = Runtime'.Serialize.serialize [] (spec) in
        fun t -> apply ~f:serialize t

      let from_proto =
        let constructor = fun _extensions results output -> { results; output } in
        let spec = Runtime'.Deserialize.C.( repeated (1, (message (fun t -> RunnerResult.from_proto t)), not_packed) ^:: basic (2, string, proto3) ^:: nil ) in
        let deserialize = Runtime'.Deserialize.deserialize [] spec constructor in
        fun writer -> deserialize writer |> Runtime'.Result.open_error

    end
    module RunnerService = struct
      module SearchStream = struct
        let name = "/protos.runner.RunnerService/SearchStream"
        module Request = SearchStreamRequest
        module Response = SearchStreamResponse
      end
      let searchStream =
        (module SearchStreamRequest : Runtime'.Service.Message with type t = SearchStreamRequest.t ),
        (module SearchStreamResponse : Runtime'.Service.Message with type t = SearchStreamResponse.t )

    end
  end
end
