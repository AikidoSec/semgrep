open AST_generic
module MV = Metavariable

let ( let* ) = Option.bind

(* TODO use an autogenerated mapper class *)
let rec replace_metavars metavars = function
  | E expr -> E (replace_metavars_expr metavars expr)
  | x -> x

and replace_metavars_expr metavars expr =
  let kind =
    match expr.e with
    | Call (e, args) ->
        Call
          (replace_metavars_expr metavars e, replace_metavars_args metavars args)
    | x -> x
  in
  { expr with e = kind }

and replace_metavars_args metavars args =
  let b1, args, b2 = args in
  let args = List.concat_map (replace_metavars_arg metavars) args in
  (b1, args, b2)

and replace_metavars_arg metavars arg =
  match arg with
  | Arg { e = N (Id ((id_str, _), _)); _ } -> (
      match List.assoc_opt id_str metavars with
      | Some (MV.Args args) -> args
      | _ -> [ arg ])
  | _ -> [ arg ]

let ( ^* ) x y =
  match (x, y) with
  | Some x, Some y -> Some (x ^ y)
  | _ -> None

let map_all f lst =
  let res = List.filter_map f lst in
  if List.length lst = List.length res then Some res else None

let rec pretty_print_python = function
  | E expr -> pretty_print_python_expr expr
  | _ -> None

and pretty_print_python_expr expr =
  match expr.e with
  | Call (e, args) ->
      pretty_print_python_expr e ^* pretty_print_python_args args
  | N (Id ((str, _), _)) -> Some str
  | L lit -> pretty_print_python_literal lit
  | _ -> None

and pretty_print_python_literal = function
  | Bool (b, _) -> if b then Some "True" else Some "False"
  | String (str, _) -> Some ("\"" ^ str ^ "\"")
  | _ -> None

and pretty_print_python_args args =
  let b1, args, b2 = args in
  (* TODO can crash *)
  let b1 = Parse_info.str_of_info b1 in
  let b2 = Parse_info.str_of_info b2 in
  let* args = map_all pretty_print_python_arg args in
  let args = String.concat ", " args in
  Some (b1 ^ args ^ b2)

and pretty_print_python_arg = function
  | ArgKwd (id, expr) ->
      let* expr = pretty_print_python_expr expr in
      Some (fst id ^ " = " ^ expr)
  | _ -> None

let synthesize_fix lang metavars fix_pattern =
  (* Outline:
   * - parse the fix pattern
   * - replace the metavars in the pattern with the extracted metavars
   * - pretty print
   *)
  let pattern : AST_generic.any =
    Parse_pattern.parse_pattern lang fix_pattern
  in
  (*
  print_endline "PATTERN:";
  print_endline (AST_generic.show_any pattern);
  print_endline "BINDINGS:";
  print_endline (Metavariable.show_bindings metavars);
  *)
  let fixed_ast : AST_generic.any = replace_metavars metavars pattern in
  (*
  print_endline "AFTER CHANGE:";
  print_endline (AST_generic.show_any fixed_ast);
  *)
  match lang with
  | Lang.Python ->
      let text = pretty_print_python fixed_ast in
      (*
    print_endline "PRETTY PRINTED:";
    print_endline (match text with | None -> "None" | Some x -> x);
    *)
      text
  | _ -> None
